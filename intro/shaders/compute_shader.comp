#version 430

layout(local_size_x = 32) in;

struct Particle {
    vec2 position;
    vec2 velocity;
};

layout(std430, binding = 0) buffer PixelBuffer {
    Particle particles[];
};

layout(std430, binding = 1) buffer VectorFieldBuffer {
    vec2 vectorField[];
};

layout(std430, binding = 2) buffer LogoVectorFieldBuffer {
    vec4 logo_vectors[]; // Store pairs as vec4 (x1, y1, x2, y2)
};

uniform int fieldWidth;
uniform int fieldHeight;
uniform float fieldScale;

uniform vec2 logo_center;
uniform float logo_radius;

uniform int number_of_particles;
uniform int logo_vectors_size;

void main() {
    uint id = gl_GlobalInvocationID.x;
    Particle particle = particles[id];

    vec2 acceleration = vec2(0, 0);

    const float max_speed = 4.0f;

    // apply_repulsion
    const float logo_tolerance = 10.0f;
    const float repulsion_radius = 25;
    const float repulsion_strength = 5;

    if (distance(particle.position, logo_center) < logo_radius) {
        for (int i = 0; i < number_of_particles; ++i) {
            if (i == id) continue;

            const vec2 diff = particle.position - particles[i].position;
            const float dist = length(diff);
            if (dist >= repulsion_radius || dist == 0) continue;

            float force = (dist / repulsion_radius * (-repulsion_strength) + repulsion_strength);
            acceleration += normalize(diff) * force;
        }
    }

    // Calculate the field index based on the particle's position
    int x_index = int(particle.position.x / fieldScale) % fieldWidth;
    int y_index = int(particle.position.y / fieldScale) % fieldHeight;
    int vector_index = y_index * fieldWidth + x_index;

    acceleration += vectorField[vector_index];
    
    // force, that pulls particles to the logo
    const float attraction_radius = 30;
    for (int i = 0; i < logo_vectors_size; ++i) {
        vec2 vector_position = logo_vectors[i].rg;
        vec2 vector_direction = logo_vectors[i].ba;
        if (distance(particle.position, vector_position) < attraction_radius) {
            acceleration += 0.2 * vector_direction;
            acceleration += 0.1 * normalize(vector_position - particle.position);
        }
    }

    // update particle velocity
    particle.velocity += acceleration;
    if (length(particle.velocity) > max_speed) {
        particle.velocity = particle.velocity * (max_speed / length(particle.velocity));
    }

    particles[id] = particle;
}